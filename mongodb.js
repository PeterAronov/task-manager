// CRUD stands for Create, Read, Update, Delete

// const monogdb = require('mongodb');
// const MongoClient = monogdb.MongoClient;
// const ObjectID = monogdb.ObjectID;

// Instead of using the above code, we can use the following code and use distructuring

const { MongoClient, ObjectID } = require('mongodb');

const connectionURL = 'mongodb://127.0.0.1:27017'; // We don't write localhost because it slows down the application for uknown reason
const databaseName = 'task-manager';

// useNewUrlParser: true => the urlparser that was orignaly used to connect to the database is changed to the new one

MongoClient.connect(connectionURL, { useNewUrlParser: true }, (error, client) => { // Here we used the connect method to connect to the specific server
    if (error) {
        return console.log('Unable to connect to database');
    }

    const db = client.db(databaseName); // Here we use the DB method on client to get the connection for the specific database.

    // inside https://mongodb.github.io/node-mongodb-native/4.8/ go to [Collection] and then find [insertOne/insertMany]
    // inside insertMany go to the InsertManyResult callback and see the result object e.g insertedCount/insertedIds
    // In MongoDB the the unique id's are known as guID's which stands for Globally Unique Identifies and are generated by the database
    // They're designed to be unique using an algorithm without needing the server to determine what the next ID value is.
    // We can generate our own unique ID's using the ObjectId method without needing the server to generate it.

    db.collection('users').insertMany([ // Here we use the insertMany method to insert multiple documents into the collection.
        {
            name: 'Peter Aronov',
            age: 29,
            job: 'Computer Engineer'
        },
        {
            name: 'Eliran Katsav',
            age: 29,
            job: 'Chimical Engineer'
        }
    ], (error, result) => {
        if (error) {
            return console.log('Unable to insert documents');
        }

        if (result.insertedCount >= 1) {
            console.log(`${result.insertedCount} orders successfully inserted.`);
            for (const idKey in result.insertedIds) {   // for loop with in will iterate over the insertedIds object and print the id of each document.
                console.log(`with ID: ${result.insertedIds[idKey]}`); // for loop with of iterates over iterable thing and prints the value of each item like an array.
            }
        }
    })

    db.collection('tasks').insertMany([ // Here we use the insertMany method to insert multiple documents into the collection.
        {
            description: 'Clean the house',
            completed: true
        },
        {
            description: 'Go to the gym',
            completed: false
        },
        {
            description: 'Cook dinner',
            completed: true
        }
    ], (error, result) => {
        if (error) {
            return console.log('Unable to insert documents');
        }

        if (result.insertedCount >= 1) {
            console.log(result.insertedCount + ' orders successfully inserted.');
            for (const idKey in result.insertedIds) {   // for loop with in will iterate over the insertedIds object and print the id of each document.
                console.log('with ID: ' + result.insertedIds[idKey]); // for loop with of iterates over iterable thing and prints the value of each item like an array.
            }
        }
    })

    db.collection('users').findOne({ name: 'Peter Aronov' }).then((user) => { // Here we use the findOne method to find a single document in the collection.
        console.log(user);
    }).catch((error) => {
        console.log(error);
    })

    // find return a cursor object which is a pointer to the data. 
    // MongoDB assums that not every time we use find we always want to get the whole array of the documents.

    db.collection('users').find({ age: 29 }).toArray((error, users) => { // Here we use the find method to find multiple documents in the collection.
        if (error) {
            return console.log('Unable to fetch');
        }
        console.log("Find users:");
        console.log(users);
        if (users.length > 0) {
            console.log(users[0]._id.toHexString());
        }
    })

    db.collection('users').find({ age: 29 }).count((error, count) => { // Here we use the find method to find multiple documents in the collection.
        if (error) {
            return console.log('Unable to fetch');
        }

        console.log('Number of found users with age: 29 is: ' + count);
    })

    // https://www.mongodb.com/docs/manual/reference/operator/update/

    db.collection('tasks').updateMany({
        completed: false
    },
        {
            $set: {
                completed: true
            }
        }).then((result) => { // Here we use the updateMany method to update multiple documents in the collection.
            console.log(result.modifiedCount + ' documents updated.');
        }).catch((error) => {
            console.log(error);
        })
})

// So here it's giving us the representation as a string, but it's wrapping it in this object ID call
// to let us know that it's not actually a string.
// It's what comes back from this function call, which would be binary data.

const id = new ObjectID(); // New keyword says execute the function as a constructor function meaning make a new object and assign that object to the key word this.
console.log(id.id)
console.log(id.getTimestamp())
console.log(id.id.length) // 12 bytes is the length of the id.
console.log(id.toHexString())
console.log(id.toHexString().length) // 24 bytes is the length of the hex string.